# 搜索
## 问题建模
1) 初始状态$S_{0}$
2) 可选动作
3) 状态转移模型(graph)
4) 目标状态$S_{next}$
5) $cost$

| **算法**                | **核心思想**                                                                 | **优点**                          | **缺点**                          | **适用场景**                      |
|-------------------------|-----------------------------------------------------------------------------|-----------------------------------|-----------------------------------|-----------------------------------|
| **广度优先搜索 (BFS)**  | 逐层扩展，使用队列。                                                        | 完备、最优（单步成本一致）        | 高内存（O(b^d)）                  | 最短路径问题（如迷宫、罗马尼亚地图） |
| **深度优先搜索 (DFS)**  | 深入分支优先，使用栈。                                                      | 低内存（O(d)）                    | 不完备（可能无限循环）、非最优    | 内存受限、无需最优解（如部分解探索） |
| **一致代价搜索 (UCS)**  | 按路径成本 `g(n)` 优先扩展，使用优先队列。                                   | 最优（单步成本任意）              | 时间效率低（O(b^{1+C*/ε})）       | 成本敏感的最优路径（如交通规划）     |
| **贪婪最佳优先搜索**    | 依赖启发式 `h(n)` 选择节点，优先接近目标。                                   | 速度快（启发式好时）              | 不保证最优解                      | 快速近似解（如实时游戏AI）          |
| **A*搜索**              | 综合 `g(n)`（实际成本）与 `h(n)`（启发式），`f(n)=g(n)+h(n)`，优先队列扩展。 | 完备、最优（h可采纳或一致）       | 需设计高质量 `h(n)`               | 最优路径规划（如机器人导航）        |
| **迭代加深搜索 (IDS)**  | 逐层增加深度限制，重复执行深度受限的DFS。                                    | 低内存、完备、最优（单步成本一致）| 时间冗余（重复扩展浅层节点）      | 内存受限的最优解问题（如八数码）    |
| **双向搜索**            | 同时从起点和终点展开搜索，中间相遇。                                         | 时间空间减半（O(b^{d/2})）        | 需已知目标状态、实现复杂          | 已知目标的双向路径问题（如社交网络） |


不同搜索算法的本质区别在于图的展开方法。
## openlist & closedlist

对于一个搜索过程的某一时刻，openlist代表马上将要搜索的一部分节点，closedlist代表已经搜索过的节点。

对于openlist与closedlist的处理产生多种搜索算法

## 图搜索与树搜索

1) 图搜索：同时维护openlist与closedlist，closedlist中节点不会被重复搜索(原则上)，大大提高搜索效率，但需要大量空间占用。

2) 树搜索：只维护openlist，每个节点有可能被搜索多次，甚至导致无限循环，但好处是不需要额外空间维护closedlist.

## 基本搜索算法
### BFS-广度优先搜索
BFS强调搜索的广泛度，使用一个队列维护openlist.队列是先进先出的。

如状态t时，openlist为\[1,4,6\](数字代表节点)，于是会先处理队首元素1，若1是目标节点，则搜索结束；否则，将1的子节点2,3加入队列，此时openlist变为\[4,6,2,3\]，继续处理队首元素4，以此类推。

BFS完备且最优(如果相邻节点距离为定值)，但需要大量空间，时间复杂度为O(b^d)，其中b为分支因子，d为搜索深度。

图搜索与树搜索都可以应用BFS

### DFS-深度优先搜索
DFS强调搜索的深度，使用一个栈维护openlist.栈是先进后出的。

如状态t时，openlist为\[1,4,6\]，先处理栈顶元素1，若1是目标节点，则搜索结束；否则，将1的子节点2,3加入栈，此时openlist变为\[2,3,6,4\]，继续处理栈顶元素2，以此类推。

DFS不完备(可能循环, 除非维护closed list)，不最优(除非完全遍历，这时也不必再说什么深度优先了)

### 深度受限搜索
在DFS的基础上，要求搜索深度不超过常数L

如此可知，深度受限搜索不完备(可能根本搜不到)，不最优(除非完全遍历深度L以内的图，这时也不必再说什么深度优先了)

### 迭代加深搜索(BFS用DFS实现)
做多轮DFS，令L由0递增，直到找到目标。

虽然每次DFS会重复搜距离近的节点，但空间复杂度比BFS低得多。

迭代加深搜索是完备的，最优的。

### UCS-一致代价搜索(Dijkstra)
UCS强调搜索的路径成本，使用一个优先队列维护openlist.优先队列是优先级高的先出队。

优先级取决于一个f函数，每个节点都有对应的f值，指从起始节点到这个节点的最小cost.f越低，优先级越高，UCS会优先展开这些节点。

问题在于如何得知f，我们只能在搜索过程中得知从起始节点到某节点的可能花费，我们需要维护所有可能花费中的最小值，在这之后，如果再次搜索到这个节点且花费更高，那么就立即剪枝(即不做任何操作)，否则将此节点加入openlist重新搜索并更新f.

UCS是完备的，最优的，但时间复杂度较高

值得注意的是，USC由于以上操作，不再需要维护closedlist，只需维护f函数，也因此：


### 贪婪最佳优先搜索
在优先队列的基础上，改变优先级函数f，定义f为一个已知的先验函数h(称为启发式函数)，代表某节点到目标的估计花费，如直线距离等。

如果贪婪算法不维护closedlist：

是不完备(这不如UCS)，不最优的(启发式函数可能不符合实际)。

维护closedlist的贪婪最佳优先搜索是完备的，但仍然不保证最优。

### A*搜索
有一个先验函数h，代表某节点到终点的估计花费，又同时如UCS一样维护每个节点的cost函数g，令优先级函数为f = g + h，其中g在搜索过程中可能被更新。

A*搜索是完备的：类似UCS，如果两次搜索到同一节点，则比对f，若更高(大于等于)则剪枝，否则更新f并重新搜索。由于图有限，更新次数一定有限，所以总搜索量有限，因此完备。

A*搜索是否最优？这是一个优化类问题，优化h。

#### A*算法最优性——数学证明
我们从头思考$f$，$g$与$h$.
研究图$G$，记开始节点为$S$，目标节点为$E$，对$G$中每个节点$V$，都可以定义$f_{真}(V)$代表从$S$经过$V$到达$E$的所有路径中最短的实际成本，由于$G$联通，$f_{真}$良定义。

而对于整个问题，有一个全局最短路，记为$P\subset G$，显然$P$是一条没有重复的路径。
##### 命题1

$\forall V \in G, f_{真}(V)\geq f_{真}(S), 取等当且仅当V\in P$

于是，如果已知$f_{真}$，根本不用搜索，能直接给出最短路径。

一般我们不知道$f_{真}$，需要用$f$来估计。

##### 定义1

$g_{真}(V)$定义为从$S$到达$V$的所有路径中最短的实际成本

$h_{真}(V)$定义为从$V$到达$E$的所有路径中最短的实际成本

##### 命题2

$\forall V \in G, f_{真}(V)=g_{真}(V)+h_{真}(V)$

##### 定义2

$g_{t}(V)$定义为遍历过程中(状态t)已知的，$S$到达$V$的所有路径中，最小的成本

我们将$f_{真}$拆成$g_{真}+h_{真}$分别用$g$，$h$进行估计，因为实际搜索中，$g$比较好得到，在不断搜索中记录并更新就能得到g。

##### 命题3

$g_{t}(V)关于t不增，且\forall t，g_{t}(V) \leq g_{真}(V)$

##### 定理1
$\forall V \in G,若 h(V) \leq h_{真}(V)，则称h可接纳，此种情况下A*算法完备且最优(如果允许通过比较重新打开节点，否则不最优)$

##### 定义3
$对\forall V_{1},V_{2} \in G,定义D(V_{1},V_{2})为从V_{1}到V_{2}的真实最短路径成本$

##### 定理2
$若h满足三角不等式：h(V_{1})+D(V_{1},V_{2}) \leq h(V_{2}), 且h(E) = 0，则称h是一致的.一致蕴含可接纳，在图搜索中A*算法是完备且最优的，而且必定不会重新打开节点.$

定理证明详见相关文章。

#### 设计h
##### 支配
若对于可接纳的$h_{1}$，$h_{2}$有$h_{1} \geq h_{2}$，称$h_{1}$支配$h_{2}$，此时$h_{1}$严格更优。

##### 松弛法
对于原命题，我们可以取消一些限制，得到新命题，显然新命题的$h_{真}$可视为原问题的启发式函数。一般而言，这些启发式函数天然一致。

# 笔试复习
# 01
## 图灵机
图灵机由以下几部分构成
1) 一条无限长的纸带，分为一个个相邻的格子，每个格子可以记录一个符号
2) 一个读写头，可以在纸带上左右移动，能读出和擦写格子的字符
3) 一个状态寄存器，记录机器所在的状态，状态的数量是有限的
4) 有限的控制规则集合. 规则指明了在每一种状态下，根据当前字符来执行某一动作:
        
        擦写当前字符，移动读写头，改变状态

$$(Q,Σ,Γ,δ,q_{0},q_{accept},q_{reject})$$

    世界上最早的算法：欧几里德算法（最大公约数）
### 判定问题
1) P: 多项式时间内可由DTM(确定性图灵机)求解
2) NP: 多项式时间内可由NTM(非确定性图灵机)求解, 多项式时间内由DTM验证
3) NP-Hard: 多项式时间内, 所有NP问题都可以被归约为此问题
4) NP-Complete: 既是NP, 又是NP-Hard

NP是否完全等于P?
## 处理对象
1) 数据: 计算机能处理的所有符号
2) 数据元素: 数据这个集合中的一个个体
3) 数据对象: 性质相同的一类数据元素的集合
4) 数据项: 一个数据元素中有意义的最小单位
5) **数据结构**: 按照逻辑关系组织起来的一批数据,按一定的存储结构把它存储在计算机中,并在这些数据上定义了相关运算的集合

        逻辑结构: 定义了结构中的基本元素之间的相互关系
            如集合、线性结构、树形结构、图形结构等
        存储结构: 给出了结构中的基本元素之间的存储方式
                顺序存储, 链式存储...
        数据的运算: 这个结构具有的行为特征
6) **抽象数据结构**: 关注数据元素间的逻辑关系（如线性、树形、图状）, 不定义操作，仅描述结构特征
7) **抽象数据类型**: 定义数据对象 + 允许的操作 + 操作规则; 隐藏实现细节，仅暴露接口契约
### 存储结构
1) 顺序存储结构(如顺序表)：把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现

        随机访问/存取
2) 链式存储结构：不要求逻辑上相邻的结点在物理位置上亦相邻，结点间的逻辑关系是由附加的指针字段表示的

        顺序访问/存取
3) 索引存储结构：除建立存储结点信息外，还建立附加的索引表来标识结点的地址
4) 散列存储结构：就是根据结点的关键字直接计算出该结点的存储地址

## 算法
算法的基本特性: 有穷, 确定, 可行, 正确.

## 程序 = 算法 + 数据结构
程序可以是无穷的, 可以是错误的.
# 02
## 数据类型
1) 简单类型: `int, float, str, bool`
2) 容器类型: `list, tuple, set, dict`

        python中int无明确上限, 存储一个int, 需要log(n)的空间
        复数用m + nj表示, n = 1时n也不能省略
或者可以按以下方式分类:
1) 不可变类型: `str, tuple`
2) 可变类型: `list, set, dict`


        ### Python 核心数据结构操作时间复杂度

| 操作                     | list               | set                | dict               | tuple             | str               | deque              |
|--------------------------|--------------------|--------------------|--------------------|-------------------|-------------------|--------------------|
| **索引访问** `[i]`       | O(1)              | ❌ 不支持          | O(1) (键访问)     | O(1)             | O(1)             | O(1) (仅两端)      |
| **追加元素**             | O(1) (均摊)       | O(1) (均摊)       | -                 | ❌ 不可变         | ❌ 不可变         | O(1) (两端)        |
| **插入元素**             | O(n)              | ❌ 不支持          | -                 | ❌ 不可变         | ❌ 不可变         | O(1) (仅两端插入)  |
| **尾部弹出**             | O(1)              | O(1) (随机弹出)   | O(1) (popitem)    | ❌ 不可变         | ❌ 不可变         | O(1)              |
| **指定位置弹出** `pop(i)`| O(n)              | ❌ 不支持          | ❌ 不支持         | ❌ 不可变         | ❌ 不可变         | ❌ 不支持          |
| **删除元素**             | O(n)              | O(1) (平均)       | O(1) (平均)       | ❌ 不可变         | ❌ 不可变         | O(n)              |
| **查找成员** `x in obj`  | O(n)              | O(1) (平均)       | O(1) (平均)       | O(n)             | O(n)             | O(n)              |
| **遍历所有元素**         | O(n)              | O(n)              | O(n)              | O(n)             | O(n)             | O(n)              |
| **合并**                 | O(k) (k=总长)     | O(k) (k=新元素数) | ❌ 不支持          | O(k)             | O(k)             | O(m) (m=添加元素数)|
| **切片** `[i:j]`         | O(k) (k=切片长度) | ❌ 不支持          | ❌ 不支持          | O(k)             | O(k)             | ❌ 不支持          |
| **长度** `len()`         | O(1)              | O(1)              | O(1)              | O(1)             | O(1)             | O(1)              |
## 语句类型
1) 定义语句
2) 控制流语句
3) 运算语句

# 03
## 语句频度与复杂度
`for i in range(n)`在不break的情况下将运行n + 1次

# 04
## 环形队列
头指针`front=0`, 尾指针`rear=0`, 物理长度`size`
### 操作
1) 入队: `l[rear] = obj`, `rear = (rear + 1) % size`
2) 出队: `front = (front + 1) % size`
3) **capacity**: `size - 1`
4) isEmpty(): `front == rear`
5) isFull(): `(rear + 1) % size == front` 
# 06
## 散列函数设计
1) 折叠法: 分段后相加取余(可以隔数反转)
2) 平方取中: 平方后取中间2位或多位, 取余
### 开放定址(再散列)
如果冲突, 按某种方式重新分配地址, 如线性后延
### 拉链法
开摆, 散列值一样的存在同一地址下
### 负载因子$\lambda$
已占用/总容量

1) 线性探测($\lambda<1$)成功查找比对次数:

$$\frac{1}{2}(1+\frac{1}{1-\lambda})$$
2) 线性探测失败查找:

$$\frac{1}{2}(1+\frac{1}{1-\lambda})^{2}$$
3) 拉链($\lambda$无限制)成功查找:

$$1+\lambda /2$$
4) 拉链失败查找:

$$\lambda$$


| 排序方式 | 平均情况 | 最坏情况 | 最好情况 | 空间复杂度 | 稳定性 | 复杂性 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| 插入排序 | O(n²) | O(n²) | O(n) | O(1) | 稳定 | 简单 |
| 希尔排序 | O(n¹·³) | | | O(1) | 不稳定 | 较复杂 |
| 冒泡排序 | O(n²) | O(n²) | O(n) | O(1) | 稳定 | 简单 |
| 快速排序 | O(nlog₂n) | O(n²) | O(nlog₂n) | O(log₂n) | 不稳定 | 较复杂 |
| 选择排序 | O(n²)(二分查找无法优化插入后其余数据的平移) | O(n²) | O(n²) | O(1) | 不稳定 | 简单 |
| 堆排序 | O(nlog₂n) | O(nlog₂n) | O(nlog₂n) | O(1) | 不稳定 | 较复杂 |
| 归并排序 | O(nlog₂n) | O(nlog₂n) | O(nlog₂n) | O(n) | 稳定 | 较复杂 |
| 基数排序 | O(d(n+r)) | O(d(n+r)) | O(d(n+r)) | O(r) | 稳定 | 较复杂 |

| 排序算法 (Algorithm) | 是否原地 (In-place?) | 空间复杂度 (Space Complexity) | 备注 |
| :--- | :--- | :--- | :--- |
| **冒泡排序 (Bubble Sort)** | **是** | O(1) | 只需要一个临时变量用于交换。 |
| **选择排序 (Selection Sort)** | **是** | O(1) | 只需要一个临时变量用于交换和记录最小/大值索引。 |
| **插入排序 (Insertion Sort)** | **是** | O(1) | 只需要一个临时变量保存待插入的元素。 |
| **希尔排序 (Shell Sort)** | **是** | O(1) | 本质是分组的插入排序，同样是原地操作。 |
| **堆排序 (Heap Sort)** | **是** | O(1) | 直接在原数组上建堆和调整，是原地算法的典范。 |
| **快速排序 (Quick Sort)** | **是 (通常认为)** | O(log n) ~ O(n) | 空间用于递归栈。平均 O(log n)，最坏 O(n)。因其不需额外数组，被广泛认为是原地算法。 |
| **归并排序 (Merge Sort)** | **否** | O(n) | 合并（merge）步骤需要一个大小为 n 的临时数组来存放已排序的元素。 |
| **计数排序 (Counting Sort)** | **否** | O(n + k) | 需要一个大小为 k 的计数数组（k 是数据范围）。 |
| **基数排序 (Radix Sort)** | **否** | O(n + k) | 需要额外的“桶”或队列来分配元素，空间与数据量和基数有关。 |
| **桶排序 (Bucket Sort)** | **否** | O(n + k) | 需要 k 个桶来存放数据，通常用链表或动态数组实现，总空间是 O(n+k)。 |
# 07
## 二叉树
1) 严格来讲二叉树不是树, 因为左右孩子有区别
1) 满二叉树: 所有非叶子节点都有左右子节点
2) 完全二叉树: 只有最下面两层允许有叶节点, 并且叶节点同意靠左
3) 完美二叉树: 最下层满的完全二叉树
3) 二叉树内, 0度节点(叶子)比2度节点多一个(算两次得到)
## 哈夫曼编码/哈夫曼树
1) 每次找频度最小的两个字符, 创建他们的根节点, 权重是二者之和, 一直重复即可
2) 左0右1
## 二叉堆
1) 建堆复杂度为`O(n)`
2) 插入, 移除并保持堆结构, 复杂度为`O(log(n))`
3) 利用二叉堆得到堆排序, 需要交换n次最大(考虑最大堆)元素, 复杂度为`O(nlog(n))`
## 二叉搜索树
1) 与插入顺序有关
2) 插入复杂度`O(log(n))`若保持平衡
3) 删除方法多样
### 平衡二叉搜索树AVL
1) 每个根节点的平衡因子 = 左右两子树高度之差
2) 要求所有平衡因子绝对值不超过1
3) 平衡方法: 自己悟
### 二叉树等价于森林
1) 二叉树转森林: 左孩子右兄弟, 从上往下
2) 森林转二叉树: 找一个森林的第一个根当根, 左子树为此根对应的树去掉根以后的森林转二叉树, 右子树对应去掉此树后的森林转二叉树.
# 08
## 邻接矩阵
容易过于稀疏
## 邻接表, 逆邻接表
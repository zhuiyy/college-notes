以下是为线性表、递归与动态规划章节设计的Python练习题，涵盖基础到中等难度，帮助你巩固知识点：

---

### **一、线性表（数组/链表）**
1. **合并两个有序链表**  
   将两个升序链表合并为一个新的升序链表并返回。

2. **删除链表的倒数第N个节点**  
   给定一个链表，删除链表的倒数第N个节点（保证有效）。

3. **环形链表检测**  
   判断链表中是否有环，要求空间复杂度O(1)。

4. **数组中的最大连续子数组和**  
   输入一个整数数组，返回具有最大和的连续子数组的和。

5. **设计循环队列**  
   用数组实现一个循环队列，支持`enqueue`、`dequeue`、`isEmpty`、`isFull`操作。

---

### **二、递归**
1. **全排列问题**  
   给定一个不含重复数字的数组，返回其所有可能的全排列（递归回溯法）。

2. **斐波那契数列优化**  
   用递归+记忆化（Memoization）实现斐波那契数列，避免重复计算。

3. **路径计数问题**  
   一个机器人位于`m×n`网格的左上角，每次只能向右或向下移动一步，问到达右下角共有多少条不同路径？

4. **子集生成**  
   给定一个数组，返回所有可能的子集（包括空集）。

5. **反转链表（递归实现）**  
   用递归方法反转一个单链表。

---

### **三、动态规划**
1. **爬楼梯问题**  
   每次可以爬1或2阶台阶，有多少种不同的方法爬到第n阶？

2. **最长公共子序列（LCS）**  
   给定两个字符串，求它们的最长公共子序列的长度。

3. **0-1背包问题**  
   给定物品的重量和价值的数组，以及背包容量，求能装入的最大价值。

4. **编辑距离**  
   计算将字符串A转换为字符串B所需的最小操作次数（插入、删除、替换）。

5. **打家劫舍问题**  
   一排房屋，不能偷相邻的房屋，求能偷窃的最大金额（进阶：房屋成环）。

---

### **挑战题（选做）**
1. **接雨水问题**  
   给定一个非负整数数组表示柱子高度，计算下雨后能接多少雨水。

2. **正则表达式匹配**  
   实现支持`'.'`和`'*'`的正则表达式匹配（动态规划解法）。

---

建议先独立完成题目，再对比参考答案或LeetCode讨论区优化思路。如果需要部分参考答案或思路提示，可以告诉我具体题号！加油复习！ 🚀


好的！以下是每个题目的核心思路解析，帮助你理解如何解决这些问题：

---

### **一、线性表（数组/链表）**

#### **1. 合并两个有序链表**  
**思路**：  
- **迭代法**：  
  用指针遍历两个链表，比较当前节点值，将较小的节点连接到新链表，直到其中一个链表遍历完，再将剩余链表直接连接。  
- **递归法**：  
  递归比较两个链表的头节点，将较小的节点作为当前节点，然后递归合并剩余部分。

#### **2. 删除链表的倒数第N个节点**  
**思路**：  
- **双指针法**：  
  使用快慢指针，快指针先走N步，然后快慢指针一起走，直到快指针到末尾。此时慢指针指向待删除节点的前一个节点，修改指针即可删除。

#### **3. 环形链表检测**  
**思路**：  
- **快慢指针法**：  
  快指针每次走2步，慢指针每次走1步。如果存在环，快慢指针最终会相遇；如果快指针走到末尾，则无环。

#### **4. 最大连续子数组和**  
**思路**：  
- **动态规划**：  
  定义 `dp[i]` 表示以第 `i` 个元素结尾的最大子数组和。转移方程：  
  `dp[i] = max(nums[i], dp[i-1] + nums[i])`  
  最终结果是 `max(dp)`，可以优化空间复杂度到 O(1)。

#### **5. 设计循环队列**  
**思路**：  
- 用数组实现，维护头指针 `front` 和尾指针 `rear`，通过取模操作实现循环。  
- **判空**：`front == rear`  
- **判满**：`(rear + 1) % size == front`（需要浪费一个位置区分空和满）。

---

### **二、递归**

#### **1. 全排列问题**  
**思路**：  
- **回溯法**：  
  每次选择一个未使用的数字加入当前路径，标记为已使用，递归完成后撤销选择（回溯）。终止条件是路径长度等于数组长度。

#### **2. 斐波那契数列优化**  
**思路**：  
- **记忆化递归**：  
  用字典或数组缓存已计算过的斐波那契数，避免重复递归调用。例如：  
  ```python
  memo = {}
  def fib(n):
      if n in memo: return memo[n]
      if n <= 1: return n
      memo[n] = fib(n-1) + fib(n-2)
      return memo[n]
  ```

#### **3. 路径计数问题**  
**思路**：  
- **递归+记忆化**：  
  到达 `(m,n)` 的路径数等于从上方 `(m-1,n)` 和左方 `(m,n-1)` 的路径数之和。  
- **动态规划优化**：  
  直接计算组合数 `C(m+n-2, m-1)`。

#### **4. 子集生成**  
**思路**：  
- **回溯法**：  
  每个元素有两种选择（选或不选），递归生成所有可能的组合。

#### **5. 反转链表（递归实现）**  
**思路**：  
- **递归到链表末尾**：  
  递归到最后一个节点作为新头节点，然后在回溯过程中反转指针方向。例如：  
  ```python
  def reverse(head):
      if not head or not head.next: return head
      new_head = reverse(head.next)
      head.next.next = head  # 反转指针
      head.next = None
      return new_head
  ```

---

### **三、动态规划**

#### **1. 爬楼梯问题**  
**思路**：  
- **状态转移方程**：  
  `dp[i] = dp[i-1] + dp[i-2]`，初始条件 `dp[0]=1, dp[1]=1`。  
  优化为滚动变量：用两个变量代替数组，空间复杂度 O(1)。

#### **2. 最长公共子序列（LCS）**  
**思路**：  
- **二维DP表**：  
  `dp[i][j]` 表示 `text1[0..i-1]` 和 `text2[0..j-1]` 的 LCS 长度。  
  转移方程：  
  - 如果 `text1[i-1] == text2[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`  
  - 否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`

#### **3. 0-1背包问题**  
**思路**：  
- **二维DP表**：  
  `dp[i][w]` 表示前 `i` 个物品在容量 `w` 下的最大价值。  
  转移方程：  
  - 不选第 `i` 个物品：`dp[i][w] = dp[i-1][w]`  
  - 选第 `i` 个物品：`dp[i][w] = dp[i-1][w - weight[i]] + value[i]`  
  优化为滚动数组（一维DP）。

#### **4. 编辑距离**  
**思路**：  
- **二维DP表**：  
  `dp[i][j]` 表示将 `word1[0..i-1]` 转换为 `word2[0..j-1]` 的最小操作次数。  
  转移方程：  
  - 如果 `word1[i-1] == word2[j-1]`，则 `dp[i][j] = dp[i-1][j-1]`  
  - 否则，`dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])`（分别对应插入、删除、替换）。

#### **5. 打家劫舍问题**  
**思路**：  
- **线性排列**：  
  `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`  
- **环形排列**：  
  拆分为两个子问题：不偷第一间或不偷最后一间，取最大值。

---

### **四、挑战题**

#### **1. 接雨水问题**  
**思路**：  
- **双指针法**：  
  左右指针向中间移动，记录左右最大高度，每次计算当前位置能接的雨水量。  
- **动态规划**：  
  预先计算每个位置的左右最大高度，再遍历计算。

#### **2. 正则表达式匹配**  
**思路**：  
- **二维DP表**：  
  `dp[i][j]` 表示 `s[0..i-1]` 是否匹配 `p[0..j-1]`。  
  转移方程需处理 `'*'` 的特殊情况（匹配0次或多次前一个字符）。

---

### **总结**
- **线性表**：多使用双指针、迭代/递归操作链表，注意边界条件。  
- **递归**：明确终止条件和递归公式，回溯法注意撤销选择。  
- **动态规划**：定义状态、找到转移方程，优化空间复杂度。  

如果需要更详细的代码实现或具体问题讨论，可以随时告诉我！


没问题！再来一组练习题，涵盖更深入的场景和变形题，帮助强化理解和应用能力：

---

### **一、线性表进阶题**

1. **旋转链表**  
   给定一个链表的头节点，将链表每个节点向右移动 `k` 个位置（例如：`1->2->3->4->5`，k=2 → `4->5->1->2->3`）。

2. **合并K个有序链表**  
   给定一个包含 `K` 个升序链表的数组，将它们合并为一个新的有序链表。

3. **删除排序链表中的重复元素 II**  
   删除所有含有重复数字的节点（只保留原始链表中没有重复出现的数字）。

4. **下一个更大元素**  
   给定一个数组，返回一个等长的数组，`ans[i]` 是 `nums[i]` 右侧第一个比它大的元素，若没有则为 -1（单调栈解法）。

5. **设计LRU缓存**  
   使用双向链表和哈希表实现 LRU 缓存，支持 `get` 和 `put` 操作，时间复杂度 O(1)。

---

### **二、递归变形题**

1. **括号生成**  
   给定数字 `n`，生成所有有效的包含 `n` 对括号的组合（如 `n=3` 时返回 `["((()))","(()())","(())()","()(())","()()()"]`）。

2. **组合总和**  
   给定无重复元素的数组和一个目标数 `target`，找出所有和为 `target` 的唯一组合（同一数字可重复使用）。

3. **二叉搜索树验证（递归）**  
   给定一个二叉树根节点，验证它是否是二叉搜索树（递归判断左子树最大值 < 根 < 右子树最小值）。

4. **N皇后问题**  
   在 `N×N` 的棋盘上放置 `N` 个皇后，使得它们互不攻击，返回所有可能的棋盘布局。

5. **反转字符串（递归实现）**  
   编写递归函数将字符数组原地反转，要求空间复杂度 O(1)。

---

### **三、动态规划进阶题**

1. **最长递增子序列（LIS）**  
   给定整数数组，找到最长严格递增子序列的长度（优化到 O(n log n) 解法）。

2. **完全背包问题**  
   在 0-1 背包基础上，允许物品无限次选取，求最大价值（修改状态转移方程）。

3. **股票买卖最佳时机 IV**  
   给定股价数组和最多完成 `k` 次交易的限制，求最大利润（三维DP或状态压缩）。

4. **分割等和子集**  
   判断是否可以将数组分割成两个子集，使得两个子集的和相等（转化为背包问题）。

5. **最小路径和**  
   在 `m×n` 网格中，从左上到右下的路径，要求路径上的数字总和最小（二维DP或空间优化）。

---

### **四、综合挑战题**

1. **滑动窗口最大值**  
   给定数组和滑动窗口大小 `k`，返回每次窗口移动时的最大值（单调队列或堆）。

2. **字符串解码**  
   输入形如 `3[a2[c]]` 的字符串，输出解码后的 `"accaccacc"`（栈或递归处理嵌套）。

3. **通配符匹配**  
   实现支持 `'?'`（匹配任意单个字符）和 `'*'`（匹配任意序列）的通配符匹配（动态规划）。

4. **俄罗斯套娃信封问题**  
   给定信封的宽高数组，当一个信封的宽高都大于另一个时才能嵌套，求最多嵌套层数（排序后转化为LIS）。

5. **戳气球**  
   给定气球数组，戳破第 `i` 个气球获得 `nums[left] * nums[i] * nums[right]` 的积分，求最大积分（区间DP）。

---


没问题！以下是新增题目的核心思路解析，帮助你快速抓住解题关键：

---

### **一、线性表进阶题**

#### **1. 旋转链表**  
**思路**：  
1. 计算链表长度 `L`，并找到尾节点。  
2. 计算有效旋转次数 `k = k % L`（若 `k=0` 则直接返回）。  
3. 找到倒数第 `k+1` 个节点（新尾节点），其下一个节点为新头节点。  
4. 原尾节点指向原头节点，断开新尾节点与新头节点的连接。

#### **2. 合并K个有序链表**  
**思路**：  
- **分治法**：  
  将链表数组两两合并，递归分治直到合并为一个链表。  
- **优先队列**：  
  维护一个小根堆，初始将所有链表的头节点入堆。每次取堆顶（最小节点），将其下一节点入堆，直到堆为空。

#### **3. 删除排序链表中的重复元素 II**  
**思路**：  
- **双指针法**：  
  使用哑节点简化边界处理。快指针扫描重复段，慢指针跳过所有重复节点。  
- **递归法**：  
  若当前节点与下一节点值相同，递归跳过所有相同节点，否则递归处理下一节点。

#### **4. 下一个更大元素（单调栈）**  
**思路**：  
- 维护一个单调递减栈。  
- 遍历数组时，若当前元素大于栈顶元素，则栈顶元素的下一个更大元素为当前元素，弹出栈顶并记录结果。  
- 最终未弹出栈的元素对应结果为 -1。

#### **5. 设计LRU缓存**  
**思路**：  
- **双向链表**：  
  节点按访问时间排序，最近访问的节点放在头部，淘汰尾部节点。  
- **哈希表**：  
  存储键到节点的映射，实现 O(1) 的查找。  
- **操作细节**：  
  `get` 操作后需将节点移到头部；`put` 操作若超出容量则删除尾部节点。

---

### **二、递归变形题**

#### **1. 括号生成**  
**思路**：  
- **回溯法**：  
  递归过程中保证左括号数量 ≤ n，右括号数量 ≤ 左括号数量。  
  终止条件：字符串长度等于 `2n`。

#### **2. 组合总和**  
**思路**：  
- **回溯法**：  
  允许重复选择同一元素，递归时保持起始索引不变。  
  剪枝：排序数组，若当前路径和超过 `target` 则提前终止。

#### **3. 二叉搜索树验证（递归）**  
**思路**：  
- **上下界约束**：  
  递归时传递当前节点的值允许的最小和最大范围。  
  例如：左子树的所有节点值 < 根节点值，右子树的所有节点值 > 根节点值。

#### **4. N皇后问题**  
**思路**：  
- **回溯法**：  
  按行放置皇后，递归尝试每一列的位置，用集合记录已占用的列、主对角线、副对角线。  
  主对角线：`行 - 列 = 常量`；副对角线：`行 + 列 = 常量`。

#### **5. 反转字符串（递归实现）**  
**思路**：  
- **双指针递归**：  
  定义递归函数 `reverse(l, r)`，交换 `s[l]` 和 `s[r]`，递归处理 `l+1` 和 `r-1`。  
  终止条件：`l >= r`。

---

### **三、动态规划进阶题**

#### **1. 最长递增子序列（LIS）**  
**思路**：  
- **贪心+二分**：  
  维护一个递增数组 `tail`，遍历原数组时，用二分查找将当前元素插入 `tail` 中合适位置以保持递增。  
  最终 `tail` 的长度即为 LIS 长度（时间复杂度 O(n log n)）。

#### **2. 完全背包问题**  
**思路**：  
- **一维DP优化**：  
  `dp[w]` 表示容量为 `w` 时的最大价值。  
  转移方程：`dp[w] = max(dp[w], dp[w - weight[i]] + value[i])`（注意正序遍历容量）。

#### **3. 股票买卖最佳时机 IV**  
**思路**：  
- **状态压缩DP**：  
  定义 `buy[k]` 表示第 `k` 次买入后的最大利润，`sell[k]` 表示第 `k` 次卖出后的最大利润。  
  转移方程：  
  `buy[k] = max(buy[k], sell[k-1] - price)`  
  `sell[k] = max(sell[k], buy[k] + price)`

#### **4. 分割等和子集**  
**思路**：  
- **0-1背包变形**：  
  计算数组总和 `S`，若 `S` 为奇数则直接返回 False。  
  问题转化为能否选出子集和为 `S/2`。  
  转移方程：`dp[w] = dp[w] || dp[w - nums[i]]`。

#### **5. 最小路径和**  
**思路**：  
- **二维DP**：  
  `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`。  
  空间优化：用一维数组滚动更新，按行或列覆盖。

---

### **四、综合挑战题**

#### **1. 滑动窗口最大值**  
**思路**：  
- **单调队列**：  
  维护一个双端队列，队列头部始终是当前窗口最大值。当新元素入队时，弹出所有比它小的尾部元素。

#### **2. 字符串解码**  
**思路**：  
- **栈处理嵌套**：  
  遇到 `[` 时，将当前结果和乘数入栈；遇到 `]` 时，弹出栈顶乘数和字符串，拼接结果。

#### **3. 通配符匹配**  
**思路**：  
- **二维DP**：  
  `dp[i][j]` 表示 `s[0..i-1]` 和 `p[0..j-1]` 是否匹配。  
  - `p[j-1] == '*'`：`dp[i][j] = dp[i][j-1] || dp[i-1][j]`  
  - `p[j-1] == '?'` 或 `s[i-1] == p[j-1]`：`dp[i][j] = dp[i-1][j-1]`

#### **4. 俄罗斯套娃信封问题**  
**思路**：  
- **转化为LIS**：  
  按宽度升序排序，若宽度相同则按高度降序排序。对排序后的高度数组求 LIS。

#### **5. 戳气球**  
**思路**：  
- **区间DP**：  
  `dp[i][j]` 表示戳破区间 `(i,j)` 内所有气球的最大积分。  
  转移方程：  
  `dp[i][j] = max(dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])`，其中 `k` 是区间内最后一个戳破的气球。

---

### **关键总结**
- **线性表进阶**：链表操作注意虚拟头节点和双指针，数组问题多用单调栈或双端队列。  
- **递归变形**：回溯法本质是决策树的遍历，剪枝条件决定效率。  
- **动态规划**：定义状态和转移方程是核心，空间优化常通过滚动数组或状态压缩。  
- **综合挑战**：复杂问题往往拆解为经典模型（如LIS、背包、区间DP）。

如果需要进一步展开某题的代码实现或更深入的解释，随时告诉我！ 😊
在 01 背包问题中,二维数组的状态转移公式依赖于上一行的数据,
即 \( dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) \).
通过逆序遍历容量 \( j \) 的方式,当前行的更新不会影响尚未处理的状态,
因此可以直接用一维数组 \( dp[j] \) 替代二维数组的 \( dp[i][j] \).
这样,当前状态更新时 \( dp[j] = \max(dp[j], dp[j-w[i]] + v[i]) \),
其中 \( dp[j-w[i]] \) 表示上一轮的状态,巧妙地复用了同一个数组,大幅节省空间.


| 物品数 / 容量  | j=0 | j=1 | j=2 | j=3 | j=4 | j=5 |
|:-------------:|:---:|:---:|:---:|:---:|:---:|:---:|
| i = 0         |  0  |  0  |  0  |  0  |  0  |  0  |
| i = 1         |  0  |  0  |  0  |  4  |  4  |  4  |
| i = 2         |  0  |  0  |  3  |  4  |  7  |  7  |
| i = 3         |  0  |  2  |  3  |  6  |  7  |  9  |
注意,计算dp[i][j](前i个物品在重量上界为j时的最大价值)时:
    dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])
只调用了上一行,纵坐标更小的元素,所以如果我们令纵坐标倒叙遍历,横坐标正序遍历
我们可以节省一个坐标i:
    dp[j] = max(dp[j],dp[j-w[j]]+v[i])
例如上表中我们计算i = 3这行时,可以看作我们在把i = 2的行元素一个一个从右到左替换为新值
j = 5时,我们计算所谓'上一行的'max(dp[5],dp[5-w[3]]+v[3]) (*)
由于倒序遍历,此时的dp[5-w[5]]还没有经历i = 3的更新,可以认为他还处在i = 2的'年代',可以用来计算
所以上面的(*)式其实等价于max(dp[2][5],dp[2][5-w[3]]+v[3])


#################################################################################################


约瑟夫环
有n个人站成一圈,编号为1到n,从第1个人开始,每隔k个人删除一个人,直到只剩下最后一个人.问最后剩下的人的编号.

递推关系:假设J(n,k)表示n个人,每隔k个人删除一个人时,最后剩下的人编号.从0开始编号时,其递推关系为:

J(n,k)=(J(n-1,k)+k)mod(n), J(1,k)=0

最后返回J(n,k)+1即可得到最后剩下的编号(从1开始)


n个人,去除第k个:
a = list(range(1,n+1))
m = 0
for i in range(n-1):
    m = (m+k-1)%(n-i)
    a.pop(m)
print(a[0])


#################################################################################################


线性筛:
def linear_sieve(n):
    prime = []
    isprime = [1 for i in range(n+1)]
    isprime[0] = isprime[1] = 0
    for i in range(2,n+1):
        if isprime[i]:
            prime.append(i)
        for p in prime:
            if p*i > n:
                break
            isprime[p*i] = 0
            if i%p == 0:
                break
    return prime

对于任意一个数n,可以唯一分解为n = p*m,p是最小素因子
所以我们遍历m,并维护一个小于等于m的质数表prime,以及一个长为n的isprime判断表
如果isprime[m] == True,那么把m加入prime,否则不加
然后我们开始筛形如m*p的数,其中p是m*p的最小素因子,显然我们只需要筛prime中的数(小于等于m的素数)
遍历p,如果有一个时刻p[i]|m,这就意味着下一个p[i+1]对应的p[i+1]*m最小素因子不是p[i+1]了,因为p[i]|m
此时我们终止对p的遍历即可然后把所有p[1~i+1]*m全标为合数,后面的m倍数自有别人来消元
(任意一个n = p*m,n在第一个循环中走到m时,prime走到p时被消掉,这是唯一的,所以时间复杂度是O(n))(算两次,平摊分析)

#################################################################################################


糖果传递问题:
    N 位小朋友,每位小朋友初始有一定数量的糖果,糖果总数是 N 的倍数.
    目标是通过相邻小朋友之间的糖果传递,使得每个小朋友最终拥有相同数量的糖果.
    每次传递可以改变相邻两个小朋友的糖果数量,任务是找出最少的传递次数.

好的,下面是修改后的版本,没有`\n\`符号,直接使用换行:

---

### 问题描述:

给定 N 位小朋友,每位小朋友初始有一定数量的糖果,糖果总数是 N 的倍数.
目标是通过相邻小朋友之间的糖果传递,使得每个小朋友最终拥有相同数量的糖果.
每次传递可以改变相邻两个小朋友的糖果数量,任务是找出最少的传递次数.

### 思路与解决方法:

1. **设定盈亏数列 a_i**:
   将每个小朋友的糖果数与平均糖果数做差,得到一个盈亏数列 a_1, a_2, ..., a_N,其中每个 a_i 表示第 i 个小朋友相对于平均糖果数的盈亏(多余或缺少的糖果数量).

2. **定义前缀和 s_i**:
   定义前缀和 s_i 为前 i 个小朋友的盈亏和,即:
     s_i = a_1 + a_2 + ... + a_i
     目标是让所有的小朋友最终拥有相同数量的糖果,等价于让每个 s_i = 0.

3. **每次传递只改变一个 s_i**:
   每次传递糖果时,操作只会影响相邻小朋友之间的盈亏,因此每次传递仅改变一个 s_i,不影响其他 s_j(j ≠ i).
   这意味着,最少的传递次数的下界为 s_i 中非零值的个数.

4. **分段处理与递归分析**:
   如果存在某个 s_i = 0,可以将问题分为两段,递归地处理每一段.
   通过消除每一段中的非零 s_i,逐步将问题简化.

5. **特殊情况处理**:
   如果前面的小朋友的 a_i 全部没有正数,即它们的值全为负数或 0,此时我们可以直接将最后一个小朋友 a_N 的盈余传递给前面的 a_{N-1},使得 s_n = 0 并调整 s_{n-1}.

6. **最少传递次数等于非零 s_i 的个数**:
   最终,最少的传递次数等于 s_i 中非零元素的个数.
   这种传递方式能确保每次传递都有效地消除一个 s_i 的非零部分,最终使得所有的小朋友糖果数相同.

### 总结:
通过构建盈亏数列 a_i 和前缀和 s_i,并通过递归分析分段消除非零 s_i,我们得出了最少传递次数的下界,并证明该下界能够通过适当的传递操作达到.
特殊情况下,通过直接将最后一个 a_N 的盈余转移给前面的 a_{N-1},可以更加高效地处理问题.
最终的结论是,最少的传递次数等于 s_i 中非零元素的个数.

#################################################################################################

### 题目重述

实验室里有 n 根试管,每根试管的容量分别为 v1, v2, ..., vn.实验机器人一次操作可以选择一个连续区间的试管 [l, r],
对其中每根试管的容量同时增加 1 毫升.目标是将所有试管注满试剂,且试剂不能溢出,问最少需要多少次操作.

n = int(input())
k = list(map(int,input().split()))
dp = k[0]
for i in range(1,n):
    if k[i] > k[i-1]:
        dp += k[i]-k[i-1]
print(dp)

### 算法精髓

你的算法是一种基于贪心思想的解决方案,其核心在于:
关注试管容量从左到右的变化,只在容量递增的地方累加操作次数.
每次操作将区间的所有试管容量同时削减到局部最低点,有效避免了冗余操作.

#### 关键步骤
1. 初始化操作次数为第一个试管的容量（因为第一个试管必须注满）.
2. 遍历剩余试管:
   如果当前试管的容量大于前一个试管,说明需要额外的操作来填满这部分增加的容量.
   将增加的部分直接累加到操作次数中.
3. 最终的累加结果就是最少操作次数.


################################################################################################

括号匹配问题
括号匹配问题要求我们判断一个由多种括号（如 (),[],{}）组成的字符串是否是有效的.有效的括号字符串满足以下条件:

每个左括号都有对应的右括号.
左括号必须在右括号之前.
括号必须是成对出现的,且嵌套的括号也必须匹配.
使用栈解决括号匹配
栈正好适合用来处理括号匹配问题,原因在于:

我们每遇到一个左括号（如 (,[,{）时,应该将其压入栈中.
每遇到一个右括号（如 ),],}）时,我们需要从栈中弹出一个左括号,并检查它是否与当前的右括号匹配.
如果所有的右括号都能正确匹配左括号,并且栈为空,那么括号是匹配的.

########################################################



积水问题

给定一个表示海岛的二维矩阵,每个矩阵元素代表该位置的海拔高度。矩阵的边界外是海平面（海拔为0）,题目要求找出在降雨的情况下,岛屿上哪些位置可能会积水,并给出这些位置的数量。

### 积水的条件
1. **水流动规则**:水可以从某个位置流向四个相邻的方向（上、下、左、右）,并且只会流向高度相同或更低的地方。
2. **积水判断**:一个位置如果被较高的海拔位置完全围绕,且与边界不相连,就可能会积水。

### 输入格式
1. 第一行有两个整数 `m` 和 `n`,表示矩阵的尺寸（行数和列数）。
2. 接下来的 `m` 行,每行包含 `n` 个整数,表示对应位置的海拔高度。

### 输出格式
输出一个整数,表示降雨后,岛屿上可能积水的位置数量。

代码实现:
from heapq import heappop, heappush

def main():
    # Input matrix dimensions
    m, n = map(int, input().split())
    height_map = [list(map(int, input().split())) for _ in range(m)]

    # Initialize visited matrix and priority queue
    visited = [[False] * n for _ in range(m)]
    min_heap = []

    # Add all boundary cells to the priority queue
    for i in range(m):
        heappush(min_heap, (height_map[i][0], i, 0))
        heappush(min_heap, (height_map[i][n-1], i, n-1))
        visited[i][0] = visited[i][n-1] = True
    for j in range(n):
        heappush(min_heap, (height_map[0][j], 0, j))
        heappush(min_heap, (height_map[m-1][j], m-1, j))
        visited[0][j] = visited[m-1][j] = True

    # Define directions for traversal (up, down, left, right)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    water_count = 0

    # Process the priority queue
    while min_heap:
        height, x, y = heappop(min_heap)

        # Traverse neighboring cells
        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            # Check bounds and whether the cell has been visited
            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:
                # If the neighboring cell is lower than the current water level, it can hold water
                if height_map[nx][ny] < height:
                    water_count += 1

                # Update the neighbor's effective height and mark it as visited
                heappush(min_heap, (max(height, height_map[nx][ny]), nx, ny))
                visited[nx][ny] = True

    # Output the count of water-holding cells
    print(water_count)

if __name__ == "__main__":
    main()




这段代码实现了一个降雨后积水区域的计算,以下是其关键部分的逐步讲解:

### 1. **输入处理**

m, n = map(int, input().split())
height_map = [list(map(int, input().split())) for _ in range(m)]

**`m, n`**:读取矩阵的行数和列数。
**`height_map`**:读取整个矩阵,表示每个位置的海拔高度。

### 2. **初始化辅助数据结构**

visited = [[False] * n for _ in range(m)]
min_heap = []

**`visited`**:用于标记每个位置是否已经处理过,防止重复计算。
**`min_heap`**:一个最小堆（优先队列）,用来动态维护当前最低的边界高度。

---

### 3. **边界初始化**

for i in range(m):
    heappush(min_heap, (height_map[i][0], i, 0))
    heappush(min_heap, (height_map[i][n-1], i, n-1))
    visited[i][0] = visited[i][n-1] = True
for j in range(n):
    heappush(min_heap, (height_map[0][j], 0, j))
    heappush(min_heap, (height_map[m-1][j], m-1, j))
    visited[0][j] = visited[m-1][j] = True

**边界格子入队**:将矩阵四周的格子加入最小堆,作为初始水位边界。
**`heappush`**:将边界格子的高度和位置（行列号）存入堆中。
**`visited` 标记**:这些边界格子已经处理过,避免重复访问。

---

### 4. **方向数组**

directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

**方向数组**:用于表示四个相邻方向（上、下、左、右）。

---

### 5. **主循环（模拟蓄水过程）**

while min_heap:
    height, x, y = heappop(min_heap)

**`heappop`**:从堆中取出当前高度最低的格子,作为“水流”的起点。



#### **遍历相邻格子**

for dx, dy in directions:
    nx, ny = x + dx, y + dy

**邻居计算**:对当前格子的四个相邻位置进行遍历。

#### **边界检查**

if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:

检查邻居是否在矩阵范围内,且未访问过。



#### **积水判断**

if height_map[nx][ny] < height:
    water_count += 1

如果相邻格子的高度低于当前水位,则该位置可以积水,累计计数。


#### **更新水位**

heappush(min_heap, (max(height, height_map[nx][ny]), nx, ny))
visited[nx][ny] = True

**`max(height, height_map[nx][ny])`**:水位取决于当前位置的水位和邻居高度的最大值。
**加入堆**:将更新后的格子作为新的边界加入最小堆。
**标记访问**:防止重复处理。


### 算法核心思想
1. **优先队列的动态边界更新**:通过从最低边界开始扩展,动态维护水位的变化,确保所有积水区域被正确计算。
2. **边界格子的约束作用**:边界高度限制了内部格子能否积水。
3. **逐步扩大水位范围**:水只能向外扩展到比自己低的区域,直到所有可访问区域被处理完毕。


key;
积水的条件不仅仅是高度小于当前水位,还需要满足 水无法从当前格子向外流出 的条件。这意味着:

格子周围的高度至少和当前水位一样高,否则水会流走。
水位是动态更新的,不能只看原始高度。
因此,在本算法中:
    当邻居高度小于当前水位时,会被判定为暂时可以积水。
    但邻居会加入堆,并在后续处理中被动态更新水位,这会导致积水状态发生变化。

###################################################################################

叶:没有子节点

最后一个非叶子节点的索引为len(l)/2-1

堆排序:
    https://www.bilibili.com/video/BV1HYtseiEQ8/?spm_id_from=333.337.search-card.all.click&vd_source=3b4f8daf13bc1fd1e544f0ef2e666018
    1.建（大根）堆:
        从最后一个非叶节点开始向上遍历非叶节点。与两个子节点的最大值比较,如果最大值更大就交换
        一定注意！如果(i,2*i+1)交换了,那么可能会破坏以2*i+1为根的子树,所以要重新比较2*i+1的节点
        因此又要比较下一个...得递归
        这样能保证最大值浮到堆顶,成为一个大根堆
    2.交换:
        把最大值沉到堆底,不管了,这个已经排序完毕,此时被交换的元素到了堆顶
        类似第1步,我们递归修复这个操作可能导致的堆破坏
    3.一直重复即可




##########################################################################################################
最长上升子序列

基础方法:O(n^2)
    l = list(map(int, input().split()))
    for i in range(0, len(l)):
        try:
            dp.append(max(dp[j] + 1 for j in filter(lambda x: l[x] <= l[i], range(i))))
        except Exception:
            dp.append(1)
    print(max(dp))

进阶方法:O(n*logn)
    希望把max中的查找改为二分查找
    但二分查找的要求是有序
    我们需要另一个list来记录最长子序列， 争取能有序排列，在二分速度下知道要把新元素接在哪
    关键观察:若存在多个相同长度的上升子序列,应保留末尾元素最小的那个,因为它更有可能被后续元素扩展。
    这个时候我们就不用存储所有结尾为l[i]的len(l)种情况了,直接存储上升子序列可能长度种情况
    继续观察:我们也不用存储完整的子序列,只用存储末尾元素,并不断更新（让它变得更小）即可

    故维护最小末尾数组
    定义tails数组,其中tails[i]表示长度为i+1的LIS的最小末尾元素。
    在一个时间状态t下，tails[i]代表前t个元素种可能产生的长度为i+1的最长上升子列，末尾元素的最小值

    二分查找加速插入
    对每个新元素x:
        若x > tails[-1]:直接追加到tails末尾,LIS长度+1
        否则:在tails中找到第一个≥x的位置,将其替换为x（维护元素最小这件事情）
            注意:这个位置之前的元素肯定不用换，因为x比他们大，这个位置之后的元素也不用换，因为x无法代替他们（上一个也比x大），只能保持原样
            可以思考1 2 3 4 6 7 5 这个数列在处理“5”时会发生什么
            处理前:tails = [1, 2, 3, 4, 6, 7]
            处理后:tails = [1, 2, 3, 4, 5, 7]

    发现tails的性质:递增，这是显然的
    可以认为tails是最长递增子列里面比较特殊的一个

    输出len(tails)即可

 
####################################################################################
快慢指针法 解决链表是否有环问题 空间复杂度O(1)
一个指针一次走两步，一个指针一次走一步，能再次相遇就是有环
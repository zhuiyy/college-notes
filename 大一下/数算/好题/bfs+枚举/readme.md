# [250406:两座孤岛最短距离](http://xzmdsa.openjudge.cn/2025hw4/250406/)
总时间限制: 60ms 内存限制: 65536kB
## 描述
给一个由1跟0组成的方形地图，1代表土地，0代表水域

相邻(上下左右4个方位当作相邻)的1组成孤岛

现在你可以将0转成1，搭建出一个链接2个孤岛的桥

请问最少要将几个0转成1，才能建成链接孤岛的桥。

题目中恰好有2个孤岛(顾答案不会是0)

## 输入
一个正整数n，代表几行输入
n行0跟1字串
## 输出
一个正整数k，代表最短距离
## 样例输入
3
110
000
001
## 样例输出
2
## 提示
样例输入中的两个孤岛最短距离为2
## 注意
我的代码并不是最优的

# 坑
### 1.小情况用二维列表维护closedlist要由于哈希表，查找更容易(有待商榷，可能占内存多)

### 2.不要用一个neighbour函数来返回可能的neighbour迭代器，很慢，直接写actions即可

### 3.最后的距离可以枚举，也可以bfs，甚至是双向bfs，bfs总的来说更快

### 4. collections.deque要远优于queue.Queue
最好用append，extend，popleft的组合实现队列

### 5. 可以在一个大循环里解决这种连通块区分问题，不要循环两遍

### 6.此类问题**DFS**和BFS一样快且有效！！不要BFS了，直接递归，还省的占空间

### 7.字符串切片速度慢于列表查找，因为字符串切片实际上依赖于列表功能

### 8.BFS一定要在元素进入openlist后立马加入进closedlist，否则很有可能重复展开